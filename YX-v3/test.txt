
Сегодня мы станем частью большой и очень значительной транснациональной корпорации Yandex Contest. В ней работает много сотрудников и, как часто это бывает, нельзя просто так взять и найти нужный контакт человека из соседней команды, соседней группы, соседнего бизнес-юнита. Иной раз требуется обойти большую цепочку коллег для того, чтобы получить необходимый контакт. Требуется написать программу, которая поможет нашим коллегам находить самый короткий путь от них до желаемого контакта.

graph — объект ключ/значение. Количество ключей 0 ≤ N ≤ 50, количество значений 0 ≤ N ≤ 50
startVertex — начальная вершина
endVertex — конечная вершина

Шаблон
/**
 * @param {{
 *  graph: Record<string, string[]>,
 *  startVertex: string,
 *  endVertex: string,
 * }}
 * @returns {string[]}
 */
module.exports = function solution({ graph, startVertex, endVertex }) {
    // ваш код
}

Формат ввода
Пример 1
module.exports = {
  graph: {
    Александра: ["Борис"],
    Борис: ["Александра", "Светлана"],
    Светлана: ["Борис"],
  },
  startVertex: "Александра",
  endVertex: "Светлана",
};

Формат вывода
Пример 1
Самый короткий путь от Александры до Светланы

["Александра", "Борис", "Светлана"]


Шахматный король стоит в левом верхнем углу шахматной доски размером  N×M. За один шаг он может перейти в соседнюю клетку ниже, либо в клетку правее, либо в клетку правее и ниже. Его цель — добраться таким образом до правого нижнего угла доски.

Да только вот король тот капризен, а потому не наступает трижды подряд на клетки одного цвета. Доска имеет стандартную шахматную покраску: каждая клетка является либо чёрной, либо белой, а цвет каждой пары имеющих общую сторону клеток различен.

Сколько существует различных путей, которыми капризный король смог бы добраться до своей цели? В ответ вывести число таких путей по модулю 1000.

Формат ввода
Входные данные содержат два натуральных числа N и M, разделённые одним пробелом. Оба числа не превосходят 100.

Формат вывода
Вывести одно целое число — ответ на вопрос задачи.


Для чтения входных данных в Node.js необходимо использовать модуль readline, который работает с потоком ввода-вывода (stdin/stdout) и позволяет читать строки. 
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

Данные во входном потоке могут состоять из нескольких строк.
Чтобы прочитать их, можно использовать метод rl.on(),
который вызывается каждый раз при появлении новой строки
в потоке ввода.
Чтобы вывести результат в поток вывода (stdout),
можно использовать метод console.log().
Пример:
console.log('Результат:', result);

Пример решения задачи "Вычислите сумму A+B":
rl.on('line', line => {
const [a, b] = line.split(' ').map(Number);
 console.log(a + b);
 rl.close();
});

решение верни используя module.exports


////////444444444444
После запуска проекта выяснилось, что у пользователей наблюдаются проблемы с памятью при длительном использовании приложения. Результаты, полученные на предыдущих запросах к бэкенду, остаются в памяти, что приводит к зависанию страницы и прочим неприятным последствиям.

Ваша команда разработала план, и вам поручили исправить эту проблему и реализовав его. План заключается в том, чтобы разработать алгоритм кэширования.

Нужно написать функцию, которая получает на вход размер кэша и возвращает интерфейс для встраивания в проект, который будет управлять кэшированием данных на странице. В процессе обсуждений было решено использовать приоритетное кэширование, где дольше сохраняются в кэше те данные, которые использовались последними.

interface EntityDataI<Data extends {id: number}> {
  setCacheChunk: (value: Data | Data[]): void;
  changeItem: (newData: Data | Data[]): void;
  getCacheItemById: (id: number): Data;
  getData: (): Data[];
}
setCacheChunk — Функция чтобы положить новую порцию данных с сервера в кэш;
changeItem — Функция для пользовательского изменения кэшированных данных;
getCacheItemById — Функция для получения элемента из кэша по id;
getAppCache — Функция для получения текущего состояния кэша;
В результате у вас должна получится следующая функция:

module.exports = function getCache(maxSize) {
  // Ваш JavaScript код
}

Пример использования

const cache = getCache(3); // Размер кэша равен трем элементам

cache.setCacheChunk({id: 1}); // Добавляем 1 объект в кэш
cache.setCacheChunk([{id: 2}, {id: 3}]); // Добавляем несколько объектов в кэш
cache.getData() // [{id: 1}, {id: 2}, {id: 3}]

cache.setCacheChunk({id: 4}); // Добавляем 1 объект в заполненный кэш
cache.getData() // [{id: 2}, {id: 3}, {id: 4}]

cache.changeItem({id: 3, log: 'some data'}); // Изменяем объект в кэше
cache.getData() // [{id: 2}, {id: 3, log: 'some data'}, {id: 4}]

cache.setCacheChunk([{id: 5}, {id: 6}]); // Добавляем несколько объектов в заполненный кэш
cache.getData() // [{id: 3, log: 'some data'}, {id: 4}, {id: 5}, {id: 6}]

cache.setCacheChunk({id: 3, field: 'some value'}); // Измененный объект перестает быть таким
// Из-за того что объект был установлен снова, его приоритет повышен
cache.getData() // [{id: 5}, {id: 6}, {id: 3, field: 'some value}]

cache.setCacheChunk([{id: 7}, {id: 8}, {id: 9}]); // Добавляем объекты в кэш
cache.getCacheItemById(7); //Читаем объекты из кэша
cache.getCacheItemById(8);
cache.getData() // [{id: 9}, {id: 7}, {id: 8}]

На что следует обратить внимание:

Размер кэша (без измененных данных) должен быть не больше maxSize;
При вызове функции получения данных getCacheItemById, приоритет полученного элемента кэша повышается над остальными;
Добавленные элементы через setCacheChunk так же получают повышенный приоритет над остальными в порядке добавления;
Измененные пользователем данные должны оставаться в кэше;
Измененные пользователем данные не учитываются в подсчете размера кэша;
При получении с сервера новой версии измененных данных (совпадают по id) они перестают быть измененными и новая версия данных кэшируется по основным правилам.
Для корректной проверки решения, при отправке выбирайте (make) компилятор.


/////////////// 2222222222222
Максим стоит возле желоба так, что видит все грузики. Он начинает тянуть ближайший грузик вдоль желоба на себя. Определите общее количество грузиков, которые будут сдвинуты.

Максим достаточно силён, чтобы сдвинуть любое количество грузиков, а соединяющие грузики нити никогда не рвутся.

Формат ввода
В первой строке входных данных содержится два целых числа n и m, разделённых одним пробелом - количество грузиков и количество нитей ( 1⩽n⩽10 9 1⩽m⩽10  5).


Последующие m строк содержат по два разделённых пробелом целых числа ai и bi - номера соединённых i-той нитью грузиков. Грузики нумеруются с единицы в порядке удаления от Максима. 

Формат вывода
Выходные данные должны содержать единственное целое число - общее количество грузиков, которые Максим потянет на себя.


//////////////////// 3333333333333333333333
Шахматный король стоит в левом верхнем углу шахматной доски размером N×M. За один шаг он может перейти в соседнюю клетку ниже, либо в клетку правее, либо в клетку правее и ниже. Его цель — добраться таким образом до правого нижнего угла доски.
король тот капризен, а потому не наступает трижды подряд на клетки одного цвета. Доска имеет стандартную шахматную покраску: каждая клетка является либо чёрной, либо белой, а цвет каждой пары имеющих общую сторону клеток различен.

Сколько существует различных путей, которыми капризный король смог бы добраться до своей цели? В ответ вывести число таких путей по модулю 1000.

Формат ввода
Входные данные содержат два натуральных числа N и M, разделённые одним пробелом. Оба числа не превосходят 100.

Формат вывода
Вывести одно целое число — ответ на вопрос задачи.

////////////// 55555555555555%%
В мире, где остался только TypeScript, только лучшие мастера кода способны использовать эту священную магию. Они не просто пишут код... Проводят тайные ритуалы, превращая строки кода в заклинания, которые обладают реальной магической силой.

Через мастерство, владение секретами TypeScript и умение проявлять чудеса рекурсии и суммирования, код объединяет мир, оставляясь последней волшебной связью между настоящим и прошлым программирования.

Сможете ли пройти ритуал посвящения в мастера кода и доказать, что вы истинный программист?

Ваша задача — написать определение типа Solution, которой принимает на вход число и возвращает его цифровой корень (also repeated digital sum). Цифровой корень числа — это результат рекурсивного суммирования всех его цифр до тех пор, пока в результате не получится однозначное число.

Примеры тестов:
Solution<0>; // 0
Solution<10>; // 1
Solution<42>; // 6
Solution<123>; // 6
Solution<123456>; // 3
Solution<111111111>; // 9
Solution<999999999>; // 9


Формат ввода
Ваше решение должно содержать определение типа Solution.

type Solution<T extends number> = ...


Примечания
Код будет выполняться на typescript@4.8.4